free c: channel.

type host. (*U, V*)
type derivedKey. (*K_i*)
type preSharedkey. (*PSK*)
type nonce. (*N_U & N_V*)
type G. (*Commonly known g*)
type exponent. (*x & y*)

(*Message Types*)
free MSG_TYPE_1 : bitstring.
free MSG_TYPE_2 : bitstring.
free MSG_TYPE_3 : bitstring.

(*Shared Key Encryption*)
fun sharedEncrypt(bitstring, derivedKey, bitstring): bitstring.
reduc forall x: bitstring, y: derivedKey, aad: bitstring; sharedDecrypt(sharedEncrypt(x, y, aad), y, aad) = x.

(*Identify the selected pre-shared key*)
fun identifyPreSharedKey(bitstring, bitstring): preSharedkey.
(*Key derivation function*)
fun HKDF(G, bitstring, preSharedkey): derivedKey.

(*Hash function*)
fun hash(bitstring): bitstring.

(*Diffie Hellman*)
(*From ProVerif examples - DiffieHellMan-active.pv*)
const g: G.
fun exp(G, exponent): G.
equation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).

(*Secrecy*)
query attacker(new APP_2);
      attacker(new APP_3).

(*
Initiator process (U)
U & V are the two hosts in the protocol
PSKs = A set of pre-shared keys
*)
let initiator(U: host, V: host, PSKs : bitstring) =
  (*Generate exponent for g^x*)
  new x : exponent;
  (*Generate first part of the Diffie HellMan shared secret*)
  let E_U : G = exp(g, x) in
    (*Session identifier*)
    new S_U : bitstring;
    (*Random Nonce*)
    new N_U : nonce;
    (*Key identifier*)
    new KID : bitstring;
    (*Opaque application data*)
    new APP_1 : bitstring;
      (*Select a pre-shared key to use*)
      let PSK : preSharedkey = identifyPreSharedKey(KID, PSKs) in
        (*Generate contents of message 1*)
        let message_1 : bitstring = (MSG_TYPE_1, S_U, N_U, E_U, KID, APP_1) in
          (*Send message 1*)
          out(c, message_1);
          (*Recieve message 2*)
          in(c, message_2 : bitstring);
          (*Split message 2 into raw data and the encryption*)
          let (data_2 : bitstring, COSE_ENC_2 : bitstring) = message_2 in
            (*Get contents of the data*)
            let (=MSG_TYPE_2, =S_U, xS_V : bitstring, xN_V : nonce, xE_V : G) = data_2 in
              (*Compute hash to message 2*)
              let aad_2 : bitstring = hash((message_1, data_2)) in
                (*Compute shared secret g^y^x*)
                let K : G = exp(xE_V, x) in
                  (*Derive K_2 with the Diffie Hellman shared secret, the hash and use the pre-shared key as a salt*)
                  let K_2 : derivedKey = HKDF(K, aad_2, PSK) in
                    (*Decrypt the encryption. Save and validate the contents*)
                    let (APP_2 : bitstring) = sharedDecrypt(COSE_ENC_2, K_2, aad_2) in
                      (*Generate data payload of message 3*)
                      let data_3 : bitstring = (MSG_TYPE_3, xS_V) in
                        (*Compute hash to message 3 with selected hash algorithm*)
                        let aad_3 : bitstring = hash((hash((message_1, message_2)), data_3)) in
                          (*Derive K_3 with the Diffie Hellman shared secret, the hash and use the pre-shared key as a salt*)
                          let K_3 : derivedKey = HKDF(K, aad_3, PSK) in
                            (*Application data*)
                            new APP_3 : bitstring;
                            (*Generate contents of message 3*)
                            let message_3 : bitstring = (data_3, sharedEncrypt(APP_3, K_3, aad_3)) in
                              (*Send message 3*)
                              out(c, message_3).


(*
Responder process (V)
V & U are the two hosts in the protocol
PSKs = A set of pre-shared keys
*)
let responder(V: host, U: host, PSKs : bitstring) =
  (*Generate exponent for g^y*)
  new y : exponent;
  (*Generate first part of the Diffie HellMan shared secret*)
  let E_V : G = exp(g, y) in
    (*Session identifier*)
    new S_V : bitstring;
    (*Recieve message 1*)
    in(c, message_1 : bitstring);
    (*Get contents of the message 1*)
    let (=MSG_TYPE_1, xS_U : bitstring, N_U : nonce, xE_U: G, xKID : bitstring, APP_1 : bitstring) = message_1 in
      (*Random Nonce*)
      new N_V: nonce;
      (*Application data*)
      new APP_2 : bitstring;
      (*Select a pre-shared key to use*)
      let PSK : preSharedkey = identifyPreSharedKey(xKID, PSKs) in
        (*Generate data payload of message 2*)
        let data_2 : bitstring = (MSG_TYPE_2, xS_U, S_V, N_V, E_V) in
          (*Compute hash to message 2*)
          let aad_2 : bitstring = hash((message_1, data_2)) in
            (*Compute shared secret g^x^y*)
            let K : G = exp(xE_U, y) in
              (*Derive K_2 with the Diffie Hellman shared secret, the hash and use the pre-shared key as a salt*)
              let K_2 : derivedKey = HKDF(K, aad_2, PSK) in
                (*Generate contents of message 2*)
                let message_2 : bitstring = (data_2, sharedEncrypt(APP_2, K_2, aad_2)) in
                  (*Send message 2*)
                  out(c, message_2);
                  (*Recive message 3*)
                  in(c, message_3 : bitstring);
                  (*Split message 3 into raw data and the encryption*)
                  let (data_3 : bitstring, COSE_ENC_3 : bitstring) = message_3 in
                    (*Get contents of the data*)
                    let (=MSG_TYPE_3, =S_V) = data_3 in
                      (*Compute hash to message 3*)
                      let aad_3 : bitstring = hash((hash((message_1, message_2)), data_3)) in
                        (*Derive K_3 with the Diffie Hellman shared secret, the hash and use the pre-shared key as a salt*)
                        let K_3 : derivedKey = HKDF(K, aad_3, PSK) in
                          (*Decrypt the encryption and save and validate the contents*)
                          let (APP_3 : bitstring) = sharedDecrypt(COSE_ENC_3, K_3, aad_3) in
                            0.

process
    (*Creating hosts*)
    new U: host; new V: host;

    (*Pre-shared keys*)
    new PSKs : bitstring;

    ( !initiator(U, V, PSKs)
    | !responder(V, U, PSKs))
