free c: channel.

type host. (*U, V*)
type derivedKey. (*K_i*)
type preSharedkey. (*PSK*)
type nonce. (*N_U & N_V*)
type G. (*Commonly known g*)
type exponent. (*x & y*)

(*Message Types*)
free MSG_TYPE_1 : bitstring.
free MSG_TYPE_2 : bitstring.
free MSG_TYPE_3 : bitstring.

(*Shared Key Encryption*)
fun sharedEncrypt(bitstring, derivedKey, bitstring): bitstring.
reduc forall x: bitstring, y: derivedKey, aad: bitstring; sharedDecrypt(sharedEncrypt(x, y, aad), y, aad) = x.

(*Identify the selected pre-shared key*)
fun identifyPreSharedKey(bitstring, bitstring): preSharedkey.
(*Key derivation function*)
fun HKDF(G, bitstring, preSharedkey): derivedKey.

(*Hash function*)
fun hash(bitstring): bitstring.

(*Diffie Hellman*)
(*From ProVerif examples - DiffieHellMan-active.pv*)
const g: G.
fun exp(G, exponent): G.
equation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).

(*Authentication events*)
event startInitiator(host, host, bitstring).
event startResponder(host, host, bitstring).
event endInitiator(host, host, bitstring, bitstring).
event endResponder(host, host, bitstring, bitstring).

(*Injective agreement*)
query U : host, V : host, S_U : bitstring, S_V : bitstring; event (endInitiator(U, V, S_U, S_V)) ==> event (startResponder(U, V, S_V)).
query U : host, V : host, S_U : bitstring, S_V : bitstring; event (endResponder(U, V, S_V, S_U)) ==> event (startInitiator(U, V, S_U)).

(*
Initiator process (U)
U & V are the two hosts in the protocol
skU = Secret key of U
PSKs = A set of pre-shared keys
*)
let initiator(U: host, V: host, PSKs : bitstring) =
  (*Generate exponent for g^x*)
  new x : exponent;
  (*Generate first part of the Diffie HellMan shared secret*)
  let E_U : G = exp(g, x) in
    (*Session identifier*)
    new S_U : bitstring;
    (*Authentication event*)
    event startInitiator(U, V, S_U);
    (*Random Nonce*)
    new N_U : nonce;
    (*Key identifier*)
    new KID : bitstring;
    (*Opaque application data*)
    new APP_1 : bitstring;
    (*Select a pre-shared key to use*)
    let PSK : preSharedkey = identifyPreSharedKey(KID, PSKs) in
      (*Generate contents of message 1*)
      let message_1 : bitstring = (MSG_TYPE_1, S_U, N_U, E_U, KID, APP_1) in
        (*Send message 1*)
        out(c, message_1);
        (*Recieve message 2*)
        in(c, message_2 : bitstring);
        (*Split message 2 into raw data and the encryption*)
        let (data_2 : bitstring, COSE_ENC_2 : bitstring) = message_2 in
          (*Get contents of the data*)
          let (=MSG_TYPE_2, =S_U, xS_V : bitstring, xN_V : nonce, xE_V : G, xAPP_2: bitstring) = data_2 in
            (*Compute hash to message 2*)
            let aad_2 : bitstring = hash((message_1, data_2)) in
              (*Compute shared secret g^y^x*)
              let K : G = exp(xE_V, x) in
                (*Derive K_2 with the Diffie Hellman shared secret, the hash and use the pre-shared key as a salt*)
                let K_2 : derivedKey = HKDF(K, aad_2, PSK) in
                  (*Decrypt the encryption. Save and validate the contents*)
                  let () = sharedDecrypt(COSE_ENC_2, K_2, aad_2) in
                    (*Generate data payload of message 3*)
                    let data_3 : bitstring = (MSG_TYPE_3, xS_V) in
                      (*Compute hash to message 3*)
                      let aad_3 : bitstring = hash((hash((message_1, message_2)), data_3)) in
                        (*Derive K_3 with the Diffie Hellman shared secret, the hash and use the pre-shared key as a salt*)
                        let K_3 : derivedKey = HKDF(K, aad_3, PSK) in
                          (*Application data*)
                          new APP_3 : bitstring;
                          (*Generate contents of message 3*)
                          let message_3 : bitstring = (data_3, sharedEncrypt(APP_3, K_3, aad_3)) in
                            (*Send message 3*)
                            out(c, message_3);
                            (*Authentication event*)
                            event endInitiator(U, V, S_U, xS_V).

(*
Responder process (V)
V & U are the two hosts in the protocol
skV = Secret key of V
PSKs = A set of pre-shared keys
*)
let responder(V: host, U: host, PSKs : bitstring) =
  (*Generate exponent for g^y*)
  new y : exponent;
  (*Generate first part of the Diffie HellMan shared secret*)
  let E_V : G = exp(g, y) in
    (*Session identifier*)
    new S_V : bitstring;
    (*Authentication event*)
    event startResponder(U, V, S_V);
    (*Recieve message 1*)
    in(c, message_1 : bitstring);
    (*Get contents of the message 1*)
    let (=MSG_TYPE_1, xS_U : bitstring, N_U : nonce, xE_U: G, xKID : bitstring, APP_1 : bitstring) = message_1 in
      (*Random Nonce*)
      new N_V: nonce;
      (*Application data*)
      new APP_2 : bitstring;
      (*Select a pre-shared key to use*)
      let PSK : preSharedkey = identifyPreSharedKey(xKID, PSKs) in
        (*Generate data payload of message 2*)
        let data_2 : bitstring = (MSG_TYPE_2, xS_U, S_V, N_V, E_V, APP_2) in
          (*Compute hash to message 2*)
          let aad_2 : bitstring = hash((message_1, data_2)) in
            (*Compute shared secret g^x^y*)
            let K : G = exp(xE_U, y) in
              (*Derive K_2 with the Diffie Hellman shared secret, the hash and use the pre-shared key as a salt*)
              let K_2 : derivedKey = HKDF(K, aad_2, PSK) in
                (*Generate contents of message 2*)
                let message_2 : bitstring = (data_2, sharedEncrypt((), K_2, aad_2)) in
                  (*Send message 2*)
                  out(c, message_2);
                  (*Recive message 3*)
                  in(c, message_3 : bitstring);
                  (*Split message 3 into raw data and the encryption*)
                  let (data_3 : bitstring, COSE_ENC_3 : bitstring) = message_3 in
                    (*Get contents of the data*)
                    let (=MSG_TYPE_3, =S_V) = data_3 in
                      (*Compute hash to message 3*)
                      let aad_3 : bitstring = hash((hash((message_1, message_2)), data_3)) in
                        (*Derive K_3 with the Diffie Hellman shared secret, the hash and use the pre-shared key as a salt*)
                        let K_3 : derivedKey = HKDF(K, aad_3, PSK) in
                          (*Decrypt the encryption and save and validate the contents*)
                          let (APP_3 : bitstring) = sharedDecrypt(COSE_ENC_3, K_3, aad_3) in
                            (*Authentication event*)
                            event endResponder(U, V, S_V, xS_U).

process
    (*Creating hosts*)
    new U: host; new V: host; new W: host;

    (*Pre-shared keys*)
    new PSKs_UV: bitstring; new PSKs_UW: bitstring; 

    ( !initiator(U, V, PSKs_UV)
    | !responder(V, U, PSKs_UV)
    | !initiator(U, W, PSKs_UW)
    | !responder(W, U, PSKs_UW)
)
